App.Capy.Board.size: Pair<U32, U32>
  {8,3}

App.Capy.Tile.size: U32
  32

App.Capy.scale: U32
  2

App.Capy.State: App.State
  App.State.new(App.Capy.Local, Unit)

type App.Capy.Local {
  lobby
  game(value: App.Capy.Game)
}

type App.Capy.Game {
  new(
    board:      App.Capy.Board
    players:    Pair<Maybe<App.Capy.Game.Player>, Maybe<App.Capy.Game.Player>>
    creatures:  Map<App.Capy.Creature>
    random:     Nat
  )
} 

App.Capy.Board: Type
  BBT<App.Capy.Coord, App.Capy.Tile>


App.Capy.Board.set(coord: App.Capy.Coord, tile: App.Capy.Tile, board: App.Capy.Board): App.Capy.Board
  BBT.insert<App.Capy.Coord, App.Capy.Tile>(App.Capy.Coord.cmp, coord, tile, board)


//Gets a tile in the board
App.Capy.Board.get(pos: App.Capy.Coord, board: App.Capy.Board):Maybe<App.Capy.Tile>
  BBT.lookup<App.Capy.Coord, App.Capy.Tile>(App.Capy.Coord.cmp, pos, board)


//Modifies something in the board
App.Capy.Board.mut(pos: App.Capy.Coord, mut: App.Capy.Tile -> App.Capy.Tile, board: App.Capy.Board): App.Capy.Board
  BBT.adjust<App.Capy.Coord, App.Capy.Tile>(App.Capy.Coord.cmp, mut, pos, board)
  


App.Capy.Coord: Type
  Pair<U32, U32>

App.Capy.Coord.cmp(a: App.Capy.Coord, b: App.Capy.Coord): Cmp
  case U32.cmp(a@fst, b@fst) {
    ltn: Cmp.ltn
    eql: U32.cmp(a@snd, b@snd)
    gtn: Cmp.gtn
  }

type App.Capy.Tile {
  new(
    creatures: List<String>
    owner:     App.Capy.Team
    class:     App.Capy.Tile.Class
  )
}

type App.Capy.Player {
  new(
    name:  String
    squad: App.Capy.Player.Squad<App.Capy.Creature.Player.Data>
  )
}


type App.Capy.Game.Player {
  new(
    name:      String
    creatures: App.Capy.Player.Squad<String>
  )
} 


type App.Capy.Player.Squad<A: Type> { 
  new(
    main: A
    lft:  A
    rgt:  A
  )
}


type App.Capy.Tile.Class {
  normal
}

type App.Capy.Team {
  fst
  snd
  none
}

type App.Capy.Creature {
  new(
    class: App.Capy.Creature.Class
    team:  App.Capy.Team
    pos:   Maybe<App.Capy.Coord>
  )
}

type App.Capy.Creature.Class {
  player(value: App.Capy.Creature.Player)
  minion(value: App.Capy.Creature.Minion)
}

type App.Capy.Creature.Player {
  new(
    data: App.Capy.Creature.Player.Data 
    // charge: Maybe<U32>
    // energy: U32
  )
}

type App.Capy.Creature.Player.Data {
  new(
    img: VoxBox
  )
}

type App.Capy.Creature.Minion {
  new(
    data: App.Capy.Creature.Minion.Data
  )
}

type App.Capy.Creature.Minion.Data {
  new(
    img: VoxBox
  )
}

type App.Capy.Game {
  new(
    board:      App.Capy.Board
    players:    Pair<Maybe<App.Capy.Game.Player>, Maybe<App.Capy.Game.Player>>
    creatures:  Map<App.Capy.Creature>
    random:     Nat
  )
}

App.Capy.Tile.init(team: App.Capy.Team): App.Capy.Tile
  App.Capy.Tile.new([], team, App.Capy.Tile.Class.normal)

App.Capy.Board.init: App.Capy.Board
  let board = BBT.tip!!
  let {x, y} = App.Capy.Board.size
  for i: U32 from 0 to x with board:
    for j: U32 from 0 to y with board:
      let team = App.Capy.Tile.init(if i <? (x / 2) then App.Capy.Team.fst else App.Capy.Team.snd)
      let board = App.Capy.Board.set({i, j}, team, board)
      board
    board
  board


App.Capy.init: App.Init<App.Capy.State>
  let board = App.Capy.Board.init
  let game = App.Capy.Game.new(board, {none, none}, {}, 0)
  let local = App.Capy.Local.game(game)
  App.Store.new<App.Capy.State>(local, unit)

App.Capy.draw(img: VoxBox): App.Draw<App.Capy.State>
  (state)
  let local = state@local
  case local {
    lobby: <div>"I'm in the Lobby"</div>
    game:
      let img   = App.Capy.draw.canvas(local.value, img)
      <div style={"width": "vw", "height": "vh", "display": "flex", "flex-direction": "row", "justify-content": "center", "align-items": "center"}>
        {
          DOM.vbox({
            "class": "pixel-art" 
            "id": "game_screen",
            "width":  U32.show(App.Capy.Tile.size * App.Capy.Board.size@fst),
            "height": U32.show(App.Capy.Tile.size * App.Capy.Board.size@snd),
            "scale":  U32.show(App.Capy.scale),
          },
          {},
          img)
        }
      </div>
  }

App.Capy.draw.canvas(game: App.Capy.Game, img: VoxBox): VoxBox
  open game 
  for coord:tile in game.board with img:
    let {x, y} = coord
    VoxBox.Draw.rect(x * App.Capy.Tile.size, y * App.Capy.Tile.size, 0, App.Capy.Tile.size, App.Capy.Tile.size, Col32.new(255, 0, 0,255), img)
  img

App.Capy: App<App.Capy.State>
  let img = VoxBox.alloc_capacity(U32.mul(1048576, 8))
  App.new<App.Capy.State>(
    App.Capy.init
    App.Capy.draw(img)
    App.no_when<App.Capy.State>
    App.no_tick<App.Capy.State>
    App.no_post<App.Capy.State>
  )


App.Capy.create_player_with_data(data: App.Capy.Creature.Player.Data, pos: Maybe<App.Capy.Coord>, team: App.Capy.Team): App.Capy.Creature
  let player = App.Capy.Creature.Player.new(data)
  let class  = App.Capy.Creature.Class.player(player)
  App.Capy.Creature.new(class, team, pos)


App.Capy.create_minion_with_data(data: App.Capy.Creature.Minion.Data, pos: Maybe<App.Capy.Coord>, team: App.Capy.Team): App.Capy.Creature
  let minion = App.Capy.Creature.Minion.new(data)
  let class  = App.Capy.Creature.Class.minion(minion)
  App.Capy.Creature.new(class, team, pos)


App.Capy.Creatures.update_map(data: Either<App.Capy.Creature.Player.Data, App.Capy.Creature.Minion.Data> team: App.Capy.Team, pos: Maybe<App.Capy.Coord>, key: String, map: Map<App.Capy.Creature>): Map<App.Capy.Creature>
  case data { 
    left: 
      let creature = App.Capy.create_player_with_data(data.value, pos, team)
      map{key} <- creature
    right:
      let creature = App.Capy.create_minion_with_data(data.value, pos, team)
      map{key} <- creature
  }


App.Capy.new_game_player(player: App.Capy.Player): App.Capy.Game.Player
  let squad        = App.Capy.Player.Squad.new<String>(player@name|"_01", player@name|"_02", player@name|"_03")
  App.Capy.Game.Player.new(player@name, squad)



App.Capy.Creatures_create_squad(player: App.Capy.Player, team: App.Capy.Team): List<Pair<String, App.Capy.Creature>>
  let pos = 
      case team { 
        fst: some({1#32, 1#32})
        snd: some({6#32, 1#32})
        none: none
      }
  let game_player = App.Capy.new_game_player(player)
  let list = [{game_player@creatures@main, player@squad@main},
              {game_player@creatures@lft,  player@squad@lft},
              {game_player@creatures@rgt,  player@squad@rgt}]
  let result = []
  for {key, data} in list with result:
    let pos = 
      if String.eql(key, game_player@creatures@main) then
        pos
      else
        none
    List.cons!({key, App.Capy.create_player_with_data(data, pos, team)}, result)

  List.reverse!(result)


App.Capy.fold(acum: Map<App.Capy.Creature>, setter: String -> App.Capy.Creature -> Map<App.Capy.Creature> -> Map<App.Capy.Creature>, list: List<Pair<String, App.Capy.Creature>>): Map<App.Capy.Creature>
  case list { 
    nil: acum
    cons: App.Capy.fold(setter(list.head@fst, list.head@snd, acum), setter, list.tail)
  }


App.Capy.Tile.set_main_creature(name: String, tile: App.Capy.Tile): App.Capy.Tile
  let creatures = List.cons<String>(name, tile@creatures)
  tile@creatures <- creatures


App.Capy.Game.insert_player(player: App.Capy.Player, team: App.Capy.Team, game: App.Capy.Game): App.Capy.Game
  let game_player  = App.Capy.new_game_player(player)
  let game         = game@player <- game@player@fst <- some(game_player)
  let creatures    = App.Capy.Creatures_create_squad(player, team)
  let map          = App.Capy.fold(game@creatures, Map.set<App.Capy.Creature>, creatures)
  let game         = game@creatures <- map
  let pos = 
      case team { 
        fst:  {1#32, 1#32}
        snd:  {6#32, 1#32}
        none: {0#32, 0#32}
      }
  game@board <~ App.Capy.Board.mut(pos, (tile: App.Capy.Tile) tile@creatures <~ List.cons!(game_player@creatures@main))

